<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <!-- Dependency: MincReaderJS -->
    <script src="js-lib/MincReaderJS/js-lib/pako.js"></script>
    <script src="js-lib/MincReaderJS/js/hdf5_tools.js"></script>
    <script src="js-lib/MincReaderJS/js/hdf5_reader.js"></script>
    <script src="js-lib/MincReaderJS/js/minc_reader.js"></script>
    <script src="js-lib/MincReaderJS/js/VectorTools.js"></script>
    <script src="js-lib/MincReaderJS/js/Plane.js"></script>
    <script src="js-lib/MincReaderJS/js/CachedOblique.js"></script>
    <script src="js-lib/MincReaderJS/js/CachedObliqueCollection.js"></script>
    <script src="js-lib/MincReaderJS/js/ObliqueSampler.js"></script>

    <!-- Dependency: VolumeNavigator -->
    <script src="js-lib/VolumeNavigator/js-lib/dat.gui.min.js"></script>
    <script src="js-lib/VolumeNavigator/js-lib/three.js"></script>
    <script src="js-lib/VolumeNavigator/js-lib/OrbitControls.js"></script>
    <script src="js-lib/VolumeNavigator/js/VolumeNavigator.js"></script>

    <!-- Project: MincNavigator -->
    <script src="js/MincNavigator.js"></script>


    <style>
        body{
            margin: none;
            background-color: #FFF;
            font-family: sans-serif;
            color: #AAA;
        }

        #navigatorDiv{
            background-color: #FFF;
            width: 500px;
            height: 500px;
        }

        .brainSlice{
          width: 450px;
          height: 450px;
        }

        #sliceCanvas{
          border-width: 4px;
          border-style: solid;
          border-color: #0088ff;
          margin-right: 5px;
        }

        #sliceOrthoUCanvas{
          border-width: 4px;
          border-style: solid;
          border-color: #00ff55;
          margin-right: 5px;
        }

        #sliceOrthoVCanvas{
          border-width: 4px;
          border-style: solid;
          border-color: #ff3333;
        }

      .dg select{
        /*
        border: none;
        */
        color: #FFF;

        border: 1px solid #111;
        outline: 0px;
        background: transparent;
        width: 220px;
        padding: 0px 0px 0px 0px;
        font-size: 13px;
        border: 1px solid #333;
        height: 19px;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        background: url(arrow.png) 96% / 10% no-repeat;
      }

      .dg select:focus {
        outline: none;
      }

    </style>

</head>
<body>

    <p>
      <input type="file" id="myFile">
    </p>

    <div id="navigatorDiv"></div>

    <div style="display: flex;">


      <canvas id="sliceCanvas" class="brainSlice"></canvas>
      <canvas id="sliceOrthoUCanvas" class="brainSlice"></canvas>
      <canvas id="sliceOrthoVCanvas" class="brainSlice"></canvas>
    </div>

    <script>
    var mincVolume = null;
    var plane = new Plane();
    var planeOrthoU = new Plane();
    var planeOrthoV = new Plane();
    var obliqueSampler = null;
    var obliqueSamplerOrthoU = null;
    var obliqueSamplerOrthoV = null;
    var volumeNav = null;
    var cachedObliqueCollection = new CachedObliqueCollection();


    /*
      the buffer is supposed to be an hdf5
    */
    function openHdf5(buffer){
        mincVolume = readMincBuffer(buffer);
        console.log("Minc volume loaded.");

        // defining th oblique sampler
        obliqueSampler = new ObliqueSampler(mincVolume, plane);
        //obliqueSampler.update();

        obliqueSamplerOrthoU = new ObliqueSampler(mincVolume, planeOrthoU);
        //obliqueSamplerOrthoU.update();

        obliqueSamplerOrthoV = new ObliqueSampler(mincVolume, planeOrthoV);
        //obliqueSamplerOrthoV.update();

        initVolumeNavigator();

        findOptimalPreviewSamplingFactor();

        // load the first image
        // (otherwise the user would have to play with slider to show the first image)
        loadFullResSlice();
    }


    // find the optimal subsampling factor for preview
    function findOptimalPreviewSamplingFactor(){
      plane.makeFromOnePointAndNormalVector(
        volumeNav.getPlanePoint(),
        volumeNav.getPlaneNormal()
      );
      obliqueSampler.findOptimalPreviewFactor();
    }


    function initVolumeNavigator(){

      var dimensionInfo = mincVolume.getDimensionInfo();
      //var innerBoxInfo = mincVolume.getDataInnerBox();

      // the outer box size
      var outerBoxOptions = {
          xSize: dimensionInfo[0].space_length,
          ySize: dimensionInfo[1].space_length,
          zSize: dimensionInfo[2].space_length
      }

      // creating a VolumeNavigator instance
      volumeNav = new VolumeNavigator(outerBoxOptions, null, "navigatorDiv");

      // optional: this callback is called when a slider is moving (mouse down)
      volumeNav.setOnChangeCallback(loadLowResSlice);

      // optional: this callback is called when a slider is released (mouse up)
      volumeNav.setOnFinishChangeCallback(loadFullResSlice);

      // optional: add a button at the bottom of dat.gui with its associated callback.
      // originally for caching the current slice.
      volumeNav.buildGuiButton("Cache current slice",cacheSlice);
    }


    /*
      Load a subsampled slice into the canvas
    */
    function loadLowResSlice(){

      plane.makeFromOnePointAndNormalVector(
        volumeNav.getPlanePoint(),
        volumeNav.getPlaneNormal()
      );

      obliqueSampler.setSamplingFactorAutoFast(); //
      obliqueSampler.update();

      var t0 = performance.now();
      obliqueSampler.startSampling(false);
      var t1 = performance.now();
      //console.log("Sampling low res: " + (t1 - t0) + " ms.")

      var imageData = obliqueSampler.exportForCanvas(1);
      loadImageDataIntoCanvas(imageData, "sliceCanvas");

      prepareVerticeForMapping(
        obliqueSampler.getVerticeMatchList()
      );
    }


    /*
      Load a full resolution slice into the canvas
    */
    function loadFullResSlice(){

      plane.makeFromOnePointAndNormalVector(
        volumeNav.getPlanePoint(),
        volumeNav.getPlaneNormal()
      );

      obliqueSampler.setSamplingFactor(1);
      obliqueSampler.update();

      var t0 = performance.now();

      obliqueSampler.startSampling(false);
      var t1 = performance.now();
      //console.log("Sampling hi res: " + (t1 - t0) + " ms.")

      var imageData = obliqueSampler.exportForCanvas(1);
      loadImageDataIntoCanvas(imageData, "sliceCanvas");

      prepareVerticeForMapping(
        obliqueSampler.getVerticeMatchList()
      );

      loadFullResOrthoUSlice();
      loadFullResOrthoVSlice();
    }



    function loadFullResOrthoUSlice(){
      planeOrthoU.makeFromOnePointAndNormalVector(
        volumeNav.getPlanePoint(),
        volumeNav.getGimbalNormalVectorArr(1)
      );

      console.log(volumeNav.getGimbalNormalVectorArr(1));

      obliqueSamplerOrthoU.setSamplingFactor(1);
      obliqueSamplerOrthoU.update();

      obliqueSamplerOrthoU.startSampling(false);

      var imageData = obliqueSamplerOrthoU.exportForCanvas(1);
      loadImageDataIntoCanvas(imageData, "sliceOrthoUCanvas");
    }



    function loadFullResOrthoVSlice(){
      planeOrthoV.makeFromOnePointAndNormalVector(
        volumeNav.getPlanePoint(),
        volumeNav.getGimbalNormalVectorArr(0)
      );

      obliqueSamplerOrthoV.setSamplingFactor(1);
      obliqueSamplerOrthoV.update();

      obliqueSamplerOrthoV.startSampling(false);

      var imageData = obliqueSamplerOrthoV.exportForCanvas(1);
      loadImageDataIntoCanvas(imageData, "sliceOrthoVCanvas");
    }


    /*
      Callback of the gui button. It caches a slice
    */
    function cacheSlice(){
      var cachedOblique = obliqueSampler.generateCachedOblique();

      // setting the quaternion from the gimbal to the cachedOblique instance
      var q = volumeNav.getGimbalQuaternion();
      cachedOblique.setQuaternion(q.x, q.y, q.z, q.w);

      // add a cached slice to the collection
      cachedObliqueCollection.addOblique( cachedOblique );

      // update the list name on gui
      var cachedObliqueNames = cachedObliqueCollection.getObliqueNameList();
      volumeNav.buildGuiList(
        "Restore cached slice",
        cachedObliqueNames,
        loadCachedOblique
      );
    }


    /*
      Callbeck when a cached slice is selected from the gui drop-down menu
    */
    function loadCachedOblique(index){

      var cachedOblique = cachedObliqueCollection.getOblique(index);
      // if we want to set the factor manually, it's here
      //cachedOblique.setBitDepthFactor(256);
      var cachedObliqueCanvasData = cachedOblique.getCanvasData();

      if(cachedObliqueCanvasData){
        // loading the cached image into the canvas
        loadImageDataIntoCanvas(cachedObliqueCanvasData, 'sliceCanvas');

        var q = cachedOblique.getQuaternion();
        volumeNav.setGimbalQuaternionElem(q.x, q.y, q.z, q.w);
        //volumeNav.setGimbalQuaternion(cachedOblique.q);

        // Adjusting the gimbal point
        volumeNav.setPlanePoint(
          cachedOblique.getPlane().getPoint()
        );

        // mapping the cached image on the 3D polygon
        prepareVerticeForMapping(
          cachedOblique.getVerticeMatchList()
        );
      }

    }


    /*
      Loads the content of an array (most likely a uint8bitClamped) into
      a specific canvas>
    */
    function loadImageDataIntoCanvas(imgData, canvasName){
      // the imgData could be null, ie. when the plane does not
      // intersect the volume
      if(!imgData)
        return;

      //var canvas = document.createElement("canvas");
      var canvas = document.getElementById(canvasName);
      var context = canvas.getContext("2d");

      canvas.width = imgData.width;
      canvas.height = imgData.height;

      context.fillStyle = "#00ff00";
      context.fillRect(0, 0, canvas.width, canvas.height);
      context.putImageData(imgData, 0, 0);
    }





  function prepareVerticeForMapping(obliqueSmplerList){
    //var obliqueSmplerList = obliqueSampler.getVerticeMatchList();

    if(!obliqueSmplerList)
      return;

    var volNavList = volumeNav.getPlanePolygon();
    var numOfVertice = volNavList.length;
    // Note: obliqueSmplerList._3D is supposed to contain the same as volNavList
    // but not in the same order. Though we cannot expect to compare (==) them
    // to one another with a floating point precision. We'll have to use a
    // root mean square as an indicator of "closeness".
    // The goal being to reorder obliqueSmplerList so that its values are in the
    // same order as in volNavList.

    // the index of matchTable is the index of volNavList
    // while the value is the index in obliqueSmplerList
    var matchTable = [];

    // This runs in O(n²), sorry about that... (hopefully this polygon has 6 vertice max)

    // finding who is who
    for(var ref=0; ref<numOfVertice; ref++){

      var matchFound = 0;
      var bestScore = 1000; //  the lowest wins

      for(var challenger=0; challenger<numOfVertice; challenger++){

        var currentScore =
          Math.abs(volNavList[ref][0] - obliqueSmplerList[challenger]._3D[0]) +
          Math.abs(volNavList[ref][1] - obliqueSmplerList[challenger]._3D[1]) +
          Math.abs(volNavList[ref][2] - obliqueSmplerList[challenger]._3D[2]);

        if(currentScore < bestScore){
          bestScore = currentScore;
          matchFound = challenger;
        }
      }
      matchTable.push(matchFound);
    }

    // reordering the obliqueSmplerList
    var new_obliqueSmplerList = [];
    for(var v=0; v<numOfVertice; v++){
      new_obliqueSmplerList.push( obliqueSmplerList[matchTable[v]] );
    }

    // the image is a square
    var squareSide = obliqueSampler.getLargestSide();

    // conversion from 2D image coordinate convention to ThreeJS texture coordinate conventions
    // (1: origin is top-left in pixel dimensions. 2: origin is bottom left in percentage)
    var textureCoords = []
    for(var v=0; v<numOfVertice; v++){
      var imageCoords = new_obliqueSmplerList[v]._2D;
      var percentCoord = [
        imageCoords[0] / squareSide,
        1 - (imageCoords[1] / squareSide)
      ];

      textureCoords.push(percentCoord);
    }

    // sending the mapping coordinates
    volumeNav.mapTextureFromCanvas("sliceCanvas", textureCoords);

  }




    /*
      Callback at file opening
    */
    function handleFileSelect(evt) {
        var files = evt.target.files; // FileList object

        // Loop through the FileList and render image files as thumbnails.
        for (var i = 0, f; f = files[i]; i++) {
            var reader = new FileReader();

            reader.onloadend = function(event) {
                var result = event.target.result;
                openHdf5(result);
            }

            reader.onerror = function() {
                var error_message = "error reading file: " + filename;
                throw new Error(error_message);
            };

            reader.readAsArrayBuffer(files[i]);
        }
    }


    // Check for the various File API support.
    if (window.File && window.FileReader && window.FileList && window.Blob) {
        // Great success! All the File APIs are supported.
        document.getElementById('myFile').addEventListener('change', handleFileSelect, false);
    } else {
        console.log('The File APIs are not fully supported in this browser.');
    }





    </script>

</body>
</html>
